<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; I; Linux 2.0.27 i586) [Netscape]">
   <META NAME="Author" CONTENT="Claude Sammut">
   <TITLE>controlling execution</TITLE>
</HEAD>
<BODY>

<H2>
CONTROLLING EXECUTION</H2>
If we were using full predicate logic as a programming language then it
would be true that you need only provide a logical specification and the
system would do the rest. However, for reasons of efficiency, Prolog implementations
introduce simplifications which make it less than deal as a logic programming
language. While improvements to the language are sought, we have to learn
to live with some of its non-logical features.

<P>Elsewhere, we drew a <A HREF="conjunctions.html#proof tree">proof tree</A>,
which showed how Prolog searched for the answer to a simple query. The
search method is called depth first because the system attempts to follow
one path down as far as it can before backtracking and trying another one.
Unless told otherwise, Prolog always backtracks when a failure occurs.
Sometimes it is undesirable to attempt some alternatives.

<P>Suppose we wanted only the students of one of the courses which Ken
teaches:
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lectures(ken, Subject), !, studies(Student, Subject)?</PRE>
The '!' is called the <I>cut. </I>The affect of the cut is limit the alternatives
that Prolog can select. In the proof tree this looks like branches on the
right hand side of the tree have been cut off. If the goals to the right
of the cut fail then the entire clause fails and the the goal which caused
this clause to be invoked also fails. That is, if the clause which failed
has alternatives, these are not attempted.
<CENTER></CENTER>

<CENTER><IMG SRC="intro3.gif" BORDER=1 HEIGHT=173 WIDTH=384></CENTER>

</BODY>
</HTML>
