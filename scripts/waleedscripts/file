SOAP::Lite(3)         User Contributed Perl Documentation        SOAP::Lite(3)



[1mNAME[0m
       SOAP::Lite ‚àí Client and server side SOAP implementation

[1mSYNOPSIS[0m
         use SOAP::Lite;
         print SOAP::Lite
           ‚Äê> uri(‚Äôhttp://www.soaplite.com/Temperatures‚Äô)
           ‚Äê> proxy(‚Äôhttp://services.soaplite.com/temper.cgi‚Äô)
           ‚Äê> f2c(32)
           ‚Äê> result;

       The same code with autodispatch:

         use SOAP::Lite +autodispatch =>
           uri => ‚Äôhttp://www.soaplite.com/Temperatures‚Äô,
           proxy => ‚Äôhttp://services.soaplite.com/temper.cgi‚Äô;

         print f2c(32);

       Code in OO‚àístyle:

         use SOAP::Lite +autodispatch =>
           uri => ‚Äôhttp://www.soaplite.com/Temperatures‚Äô,
           proxy => ‚Äôhttp://services.soaplite.com/temper.cgi‚Äô;

         my $temperatures = Temperatures‚Äê>new(32); # get object
         print $temperatures‚Äê>as_celsius;          # invoke method

       Code with service description:

         use SOAP::Lite;
         print SOAP::Lite
           ‚Äê> service(‚Äôhttp://www.xmethods.net/sd/StockQuoteService.wsdl‚Äô)
           ‚Äê> getQuote(‚ÄôMSFT‚Äô);

       Code for SOAP server (CGI):

         use SOAP::Transport::HTTP;
         SOAP::Transport::HTTP::CGI
           ‚Äê> dispatch_to(‚Äô/Your/Path/To/Deployed/Modules‚Äô, ‚ÄôModule::Name‚Äô, ‚ÄôModule::method‚Äô)
           ‚Äê> handle;

       Visual Basic client (through COM interface):

         MsgBox CreateObject("SOAP.Lite").new( _
           "proxy", "http://services.xmethods.net/soap", _
           "uri",   "urn:xmethods‚Äêdelayed‚Äêquotes" _
         ).getQuote("MSFT").result

       mod_soap enabled SOAP server:

         .htaccess

         SetHandler perl‚Äêscript
         PerlHandler Apache::SOAP
         PerlSetVar dispatch_to "/Your/Path/To/Deployed/Modules, Module::Name"

       ASP/VB SOAP server:

         <%
           Response.ContentType = "text/xml"
           Response.Write(Server.CreateObject("SOAP.Lite") _
             .server("SOAP::Server") _
             .dispatch_to("/Your/Path/To/Deployed/Modules") _
             .handle(Request.BinaryRead(Request.TotalBytes)) _
           )
         %>

[1mDESCRIPTION[0m
       SOAP::Lite is a collection of Perl modules which provides a simple and
       lightweight interface to the Simple Object Access Protocol (SOAP) both
       on client and server side.

       This version of SOAP::Lite supports the SOAP 1.1 specification (
       http://www.w3.org/TR/SOAP ).

       The main features of the library are:

       ¬∑  Supports SOAP 1.1 spec.

       ¬∑  Interoperability tests with different implementations: Apache SOAP,
          Frontier, Microsoft SOAP, Microsoft .NET, DevelopMentor, XMethods,
          4s4c, Phalanx, Kafka, SQLData, Lucin (in Java, Perl, C++, Python,
          VB, COM, XSLT).

       ¬∑  Provides COM interface. Single dll (standalone [2.5MB] or minimal
          [32kB]).  Works on Windows 9x/Me/NT/2K. Doesn‚Äôt require ROPE or
          MSXML.  Examples in VB, Excel/VBA, C#, ASP, JavaScript, PerlScript
          and Perl.

       ¬∑  Provides transparent compression support for HTTP transport.

       ¬∑  Provides mod_soap module. Make SOAP server with a few lines in
          .htaccess or .conf file.

       ¬∑  Includes XML::Parser::Lite (regexp‚àíbased XML parser) which runs
          instead of XML::Parser where Perl 5.6 runs (even on WinCE) with some
          limitations.

       ¬∑  Includes XMLRPC::Lite, implementation of XML‚ÄêRPC protocol on client
          and server side. All transports and features of SOAP::Lite are
          available.

       ¬∑  Supports multipart/form‚àídata MIME attachments.

       ¬∑  Supports circular linked lists and multiple references.

       ¬∑  Supports Map datatype (encoding of maps/hashes with arbitrary keys).

       ¬∑  Supports HTTPS protocol.

       ¬∑  Provides proxy support.

       ¬∑  Provides CGI/daemon/mod_perl/Apache::Registry server implementa‚Äê
          tions.

       ¬∑  Provides TCP server implementation.

       ¬∑  Provides IO (STDIN/STDOUT/File) server implementation.

       ¬∑  Provides FTP client implementation.

       ¬∑  Supports single/multipart MIME attachment (parsing side only).

       ¬∑  Supports SMTP protocol.

       ¬∑  Provides POP3 server implementation.

       ¬∑  Supports M‚àíPOST and redirects in HTTP transport.

       ¬∑  Supports Basic/Digest server authentication.

       ¬∑  Works with CGI accelerators, like VelociGen and PerlEx.

       ¬∑  Supports UDDI interface on client side. See UDDI::Lite for details.

       ¬∑  Supports UDDI publishing API. Examples and documentation provided.

       ¬∑  Supports WSDL schema with stub and run‚Äêtime access.

       ¬∑  Supports blessed object references.

       ¬∑  Supports arrays (both serialization and deserialization with auto‚Äê
          typing).

       ¬∑  Supports custom serialization.

       ¬∑  Provides exception transport with custom exceptions

       ¬∑  Supports Base64 encoding.

       ¬∑  Supports XML entity encoding.

       ¬∑  Supports header attributes.

       ¬∑  Supports dynamic and static class/method binding.

       ¬∑  Supports objects‚Äêby‚Äêreference with simple garbage collection and
          activation.

       ¬∑  Provides shell for interactive SOAP sessions.

       ¬∑  Supports out parameters binding.

       ¬∑  Supports transparent SOAP calls with autodispatch feature.

       ¬∑  Provides easy services deployment. Put module in specified directory
          and it‚Äôll be accessible.

       ¬∑  Has tests, examples and documentation to let you be up and running
          in no time.

       [1mWHERE TO FIND EXAMPLES[0m

       See [4mt/*.t[24m, [4mexamples/*.pl[24m and the module documentation for a client‚Äêside
       examples that demonstrate the serialization of a SOAP request, sending
       it via HTTP to the server and receiving the response, and the deserial‚Äê
       ization of the response. See [4mexamples/server/*[24m for server‚Äêside imple‚Äê
       mentations.

[1mOVERVIEW OF CLASSES AND PACKAGES[0m
       This table should give you a quick overview of the classes provided by
       the library.

        SOAP::Lite.pm
        ‚Äê‚Äê SOAP::Lite           ‚Äê‚Äê Main class provides all logic
        ‚Äê‚Äê SOAP::Transport      ‚Äê‚Äê Supports transport architecture
        ‚Äê‚Äê SOAP::Data           ‚Äê‚Äê Provides extensions for serialization architecture
        ‚Äê‚Äê SOAP::Header         ‚Äê‚Äê Provides extensions for header serialization
        ‚Äê‚Äê SOAP::Parser         ‚Äê‚Äê Parses XML file into object tree
        ‚Äê‚Äê SOAP::Serializer     ‚Äê‚Äê Serializes data structures to SOAP package
        ‚Äê‚Äê SOAP::Deserializer   ‚Äê‚Äê Deserializes results of SOAP::Parser into objects
        ‚Äê‚Äê SOAP::SOM            ‚Äê‚Äê Provides access to deserialized object tree
        ‚Äê‚Äê SOAP::Constants      ‚Äê‚Äê Provides access to common constants
        ‚Äê‚Äê SOAP::Trace          ‚Äê‚Äê Provides tracing facilities
        ‚Äê‚Äê SOAP::Schema         ‚Äê‚Äê Provides access and stub(s) for schema(s)
        ‚Äê‚Äê SOAP::Schema::WSDL   ‚Äê‚Äê WSDL implementation for SOAP::Schema
        ‚Äê‚Äê SOAP::Server         ‚Äê‚Äê Handles requests on server side
        ‚Äê‚Äê SOAP::Server::Object ‚Äê‚Äê Handles objects‚Äêby‚Äêreference
        ‚Äê‚Äê SOAP::Fault          ‚Äê‚Äê Provides support for Faults on server side

        SOAP::Transport::HTTP.pm
        ‚Äê‚Äê SOAP::Transport::HTTP::Client  ‚Äê‚Äê Client interface to HTTP transport
        ‚Äê‚Äê SOAP::Transport::HTTP::Server  ‚Äê‚Äê Server interface to HTTP transport
        ‚Äê‚Äê SOAP::Transport::HTTP::CGI     ‚Äê‚Äê CGI implementation of server interface
        ‚Äê‚Äê SOAP::Transport::HTTP::Daemon  ‚Äê‚Äê Daemon implementation of server interface
        ‚Äê‚Äê SOAP::Transport::HTTP::Apache  ‚Äê‚Äê mod_perl implementation of server interface

        SOAP::Transport::POP3.pm
        ‚Äê‚Äê SOAP::Transport::POP3::Server  ‚Äê‚Äê Server interface to POP3 protocol

        SOAP::Transport::MAILTO.pm
        ‚Äê‚Äê SOAP::Transport::MAILTO::Client ‚Äê‚Äê Client interface to SMTP/sendmail

        SOAP::Transport::LOCAL.pm
        ‚Äê‚Äê SOAP::Transport::LOCAL::Client ‚Äê‚Äê Client interface to local transport

        SOAP::Transport::TCP.pm
        ‚Äê‚Äê SOAP::Transport::TCP::Server ‚Äê‚Äê Server interface to TCP protocol
        ‚Äê‚Äê SOAP::Transport::TCP::Client ‚Äê‚Äê Client interface to TCP protocol

        SOAP::Transport::IO.pm
        ‚Äê‚Äê SOAP::Transport::IO::Server ‚Äê‚Äê Server interface to IO transport

       [1mSOAP::Lite[0m

       All methods that "SOAP::Lite" provides can be used for both setting and
       retrieving values. If you provide no parameters, you will get current
       value, and if parameters are provided, a new value will be assigned to
       the object and the method in question will return the current object
       (if not stated otherwise). This is suitable for stacking these calls
       like:

         $lite = SOAP::Lite
           ‚Äê> uri(‚Äôhttp://simon.fell.com/calc‚Äô)
           ‚Äê> proxy(‚Äôhttp://soap.4s4c.com/ssss4c/soap.asp‚Äô)
         ;

       The order is insignificant and you may call the [4mnew()[24m method first. If
       you don‚Äôt do it, SOAP::Lite will do it for you. However, the [4mnew()[0m
       method gives you an additional syntax:

         $lite = new SOAP::Lite
           uri => ‚Äôhttp://simon.fell.com/calc‚Äô,
           proxy => ‚Äôhttp://soap.4s4c.com/ssss4c/soap.asp‚Äô
         ;

       [4mnew()[0m
           [4mnew()[24m accepts a hash with method names as keys. It will call the
           appropriate methods together with the passed values. Since [4mnew()[24m is
           optional it won‚Äôt be mentioned anymore.

       [4mtransport()[0m
           Provides access to the "SOAP::Transport" object. The object will be
           created for you. You can reassign it (but generally you should
           not).

       [4mserializer()[0m
           Provides access to the "SOAP::Serialization" object. The object
           will be created for you. You can reassign it (but generally you
           should not).

       [4mproxy()[0m
           Shortcut for "transport‚àí>proxy()". This lets you specify an end‚Äê
           point (service address) and also loads the required module at the
           same time. It is required for dispatching SOAP calls. The name of
           the module will be defined depending on the protocol specific for
           the endpoint. The prefix "SOAP::Transport" will be prepended, the
           module will be loaded and object of class (with appended
           "::Client") will be created.

           For example, for [4mhttp://localhost/[24m, the class for creating objects
           will look for "SOAP::Transport:HTTP::Client";

           In addition to endpoint parameter, [4mproxy()[24m can accept any transport
           specific parameters that could be passed as name => value pairs.
           For example, to specify proxy settings for HTTP protocol you may
           do:

             $soap‚Äê>proxy(‚Äôhttp://endpoint.server/‚Äô,
                          proxy => [‚Äôhttp‚Äô => ‚Äôhttp://my.proxy.server/‚Äô]);

           Notice that since proxy (second one) expects to get more than one
           parameter you should wrap them in array.

           Another useful example can be the client that is sensitive to
           cookie‚Äêbased authentication. You can provide this with:

             $soap‚Äê>proxy(‚Äôhttp://localhost/‚Äô,
                          cookie_jar => HTTP::Cookies‚Äê>new(ignore_discard => 1));

           You may specify timeout for HTTP transport with following code:

             $soap‚Äê>proxy(‚Äôhttp://localhost/‚Äô, timeout => 5);

       [4mendpoint()[0m
           Lets you specify an endpoint [1mwithout [22mchanging/loading the protocol
           module.  This is useful for switching endpoints without switching
           protocols. You should call "proxy()" first. No checks for protocol
           equivalence will be made.

       [4moutputxml()[0m
           Lets you specify the kind of output from all method calls. If
           "true", all methods will return unprocessed, raw XML code. You can
           parse it with XML::Parser, SOAP::Deserializer or any other appro‚Äê
           priate module.

       [4mautotype()[0m
           Shortcut for "serializer‚àí>autotype()". This lets you specify
           whether the serializer will try to make autotyping for you or not.
           Default setting is "true".

       [4mreadable()[0m
           Shortcut for "serializer‚àí>readable()". This lets you specify the
           format for the generated XML code. Carriage returns <CR> and inden‚Äê
           tation will be added for readability. Useful in the case you want
           to see the generated code in a debugger. By default, there are no
           additional characters in generated XML code.

       [4mnamespace()[0m
           Shortcut for "serializer‚àí>namespace()". This lets you specify the
           default namespace for generated envelopes (‚ÄôSOAP‚àíENV‚Äô by default).

       [4mencodingspace()[0m
           Shortcut for "serializer‚àí>encodingspace()". This lets you specify
           the default encoding namespace for generated envelopes (‚ÄôSOAP‚àíENC‚Äô
           by default).

       [4mencoding()[0m
           Shortcut for "serializer‚àí>encoding()". This lets you specify the
           encoding for generated envelopes. It does not actually change enve‚Äê
           lope encoding, it will just modify the XML declaration (‚ÄôUTF‚àí8‚Äô by
           default).  Use "undef" value to [1mnot [22mgenerate XML declaration.

       [4mtypelookup()[0m
           Shortcut for "serializer‚àí>typelookup()". This gives you access to
           the "typelookup" table that is used for autotyping. For more infor‚Äê
           mation see "SOAP::Serializer".

       [4muri()[0m
           Shortcut for "serializer‚àí>uri()". This lets you specify the uri for
           SOAP methods. Nothing is specified by default and your call will
           definitely fail if you don‚Äôt specify the required uri.

           [1mWARNING[22m: URIs are just identifiers. They may [1mlook like URLs[22m, but
           they are not guaranteed to point to anywhere and shouldn‚Äôt be used
           as such pointers.  URIs assume to be unique within the space of all
           XML documents, so consider them as unique identifiers and nothing
           else.

       [4mmultirefinplace()[0m
           Shortcut for "serializer‚àí>multirefinplace()". If true, the serial‚Äê
           izer will put values for multireferences in the first occurrence of
           the reference.  Otherwise it will be encoded as top independent
           element, right after "method" element inside "Body". Default value
           is "false".

       [4mheader()[0m
           [1mDEPRECATED[22m: Use SOAP::Header instead.

           Shortcut for "serializer‚àí>header()". This lets you specify the
           header for generated envelopes. You can specify "root", "mustUnder‚Äê
           stand" or any other header using "SOAP::Data" class:

             $serializer = SOAP::Serializer‚Äê>envelope(‚Äômethod‚Äô => ‚Äômymethod‚Äô, 1,
               SOAP::Header‚Äê>name(t1 => 5)‚Äê>mustUnderstand(1),
               SOAP::Header‚Äê>name(t2 => 7)‚Äê>mustUnderstand(2),
             );

           will be serialized into:

             <SOAP‚ÄêENV:Envelope ...attributes skipped>
               <SOAP‚ÄêENV:Header>
                 <t1 xsi:type="xsd:int" SOAP‚ÄêENV:mustUnderstand="1">5</t1>
                 <t2 xsi:type="xsd:int" SOAP‚ÄêENV:mustUnderstand="1">7</t2>
               </SOAP‚ÄêENV:Header>
               <SOAP‚ÄêENV:Body>
                 <namesp1:mymethod xmlns:namesp1="urn:SOAP__Serializer">
                   <c‚Äêgensym6 xsi:type="xsd:int">1</c‚Äêgensym6>
                 </namesp1:mymethod>
               </SOAP‚ÄêENV:Body>
             </SOAP‚ÄêENV:Envelope>

           You can mix "SOAP::Header" parameters with other parameters and you
           can also return "SOAP::Header" parameters as a result of a remote
           call. They will be placed into the header. See "My::Parame‚Äê
           ters::addheader" as an example.

       [4mon_action()[0m
           This lets you specify a handler for "on_action event". It is trig‚Äê
           gered when creating SOAPAction. The default handler will set SOA‚Äê
           PAction to "uri#method". You can change this behavior globally (see
           "DEFAULT SETTINGS") or locally, for a particular object.

       [4mon_fault()[0m
           This lets you specify a handler for "on_fault" event. The default
           behavior is to [1mdie [22mon an transport error and to [1mdo nothing [22mon other
           error conditions. You may change this behavior globally (see
           "DEFAULT SETTINGS") or locally, for a particular object.

       [4mon_debug()[0m
           This lets you specify a handler for "on_debug event". Default
           behavior is to do nothing. Use "+trace/+debug" option for
           SOAP::Lite instead. If you use if be warned that since this method
           is just interface to "+trace/+debug" it has [1mglobal [22meffect, so if
           you install it for one object it‚Äôll be in effect for all subsequent
           calls (even for other objects).

       [4mon_nonserialized()[0m
           This lets you specify a handler for "on_nonserialized event". The
           default behavior is to produce a warning if warnings are on for
           everything that cannot be properly serialized (like CODE references
           or GLOBs).

       [4mcall()[0m
           Provides alternative interface for remote method calls. You can
           always run "SOAP::Lite‚àí>new(...)‚àí>method(@parameters)", but [4mcall()[0m
           gives you several additional options:

           prefixed method
               If you want to specify prefix for generated method‚Äôs element
               one of the available options is do it with [4mcall()[24m interface:

                 print SOAP::Lite
                   ‚Äê> new(....)
                   ‚Äê> call(‚Äômyprefix:method‚Äô => @parameters)
                   ‚Äê> result;

               This example will work on client side only. If you want to
               change prefix on server side you should override default seri‚Äê
               alizer. See [4mexamples/server/soap.*[24m for examples.

           access to any method
               If for some reason you want to get access to remote procedures
               that have the same name as methods of SOAP::Lite object these
               calls (obviously) won‚Äôt be dispatched. In that case you can
               originate your call trough [4mcall()[24m:

                 print SOAP::Lite
                   ‚Äê> new(....)
                   ‚Äê> call(new => @parameters)
                   ‚Äê> result;

           implementation of OO interface
               With autodispatch you can make CLASS/OBJECT calls like:

                 my $obj = CLASS‚Äê>new(@parameters);
                 print $obj‚Äê>method;

               However, because of side effects autodispatch has, it‚Äôs not
               always possible to use this syntax. [4mcall()[24m provides you with
               alternative:

                 # you should specify uri()
                 my $soap = SOAP::Lite
                   ‚Äê> uri(‚Äôhttp://my.own.site/CLASS‚Äô) # <<< CLASS goes here
                   # ..... other parameters
                 ;

                 my $obj = $soap‚Äê>call(new => @parameters)‚Äê>result;
                 print $soap‚Äê>call(method => $obj)‚Äê>result;
                 # $obj object will be updated here if necessary,
                 # as if you call $obj‚Äê>method() and method() updates $obj

                 # Update of modified object MAY not work if server on another side
                 # is not SOAP::Lite

           ability to set method‚Äôs attributes
               Additionally this syntax lets you specify attributes for method
               element:

                 print SOAP::Lite
                   ‚Äê> new(....)
                   ‚Äê> call(SOAP::Data‚Äê>name(‚Äômethod‚Äô)‚Äê>attr({xmlns => ‚Äômynamespace‚Äô})
                           => @parameters)
                   ‚Äê> result;

               You can specify [1many [22mattibutes and "name" of "SOAP::Data" ele‚Äê
               ment becomes name of method. Everything else except attributes
               is ignored and parameters should be provided as usual.

               Be warned, that though you have more control using this method,
               you [1mshould [22mspecify namespace attribute for method explicitely,
               even if you made [4muri()[24m call earlier. So, if you have to have
               namespace on method element, instead of:

                 print SOAP::Lite
                   ‚Äê> new(....)
                   ‚Äê> uri(‚Äômynamespace‚Äô) # will be ignored
                   ‚Äê> call(SOAP::Data‚Äê>name(‚Äômethod‚Äô) => @parameters)
                   ‚Äê> result;

               do

                 print SOAP::Lite
                   ‚Äê> new(....)
                   ‚Äê> call(SOAP::Data‚Äê>name(‚Äômethod‚Äô)‚Äê>attr({xmlns => ‚Äômynamespace‚Äô})
                           => @parameters)
                   ‚Äê> result;

               because in the former call [4muri()[24m will be ignored and namespace
               won‚Äôt be specified. If you run script with "‚àíw" option (as rec‚Äê
               ommended) SOAP::Lite gives you a warning:

                 URI is not provided as attribute for method (method)

               Moreover, it‚Äôll become fatal error if you try to call it with
               prefixed name:

                 print SOAP::Lite
                   ‚Äê> new(....)
                   ‚Äê> uri(‚Äômynamespace‚Äô) # will be ignored
                   ‚Äê> call(SOAP::Data‚Äê>name(‚Äôa:method‚Äô) => @parameters)
                   ‚Äê> result;

               gives you:

                 Can‚Äôt find namespace for method (a:method)

               because nothing is associated with prefix ‚Äôa‚Äô.

           One more comment. One case when SOAP::Lite will change something
           that you specified is when you specified prefixed name and empty
           namespace name:

             print SOAP::Lite
               ‚Äê> new(....)
               ‚Äê> uri(‚Äô‚Äô)
               ‚Äê> call(‚Äôa:method‚Äô => @parameters)
               ‚Äê> result;

           This code will generate:

             <method xmlns="">....</method>

           instead of

             <a:method xmlns:a="">....</method>

           because later is not allowed according to XML Namespace specifica‚Äê
           tion.

           In all other aspects "‚àí>call(mymethod => @parameters)" is just a
           synonim for "‚àí>mymethod(@parameters)".

       [4mself()[0m
           Returns object reference to [1mglobal [22mdefaul object specified with
           "use SOAP::Lite ..." interface. Both class method and object method
           return reference to [1mglobal [22mobject, so:

             use SOAP::Lite
               proxy => ‚Äôhttp://my.global.server‚Äô
             ;

             my $soap = SOAP::Lite‚Äê>proxy(‚Äôhttp://my.local.server‚Äô);

             print $soap‚Äê>self‚Äê>proxy;

           prints ‚Äôhttp://my.global.server‚Äô (the same as
           "SOAP::Lite‚àí>self‚àí>proxy").  See "DEFAULT SETTINGS" for more infor‚Äê
           mation.

       [4mdispatch_from()[0m
           Does exactly the same as autodispatch does, but doesn‚Äôt install
           UNIVERSAL::AUTOLOAD handler and only install AUTOLOAD handlers in
           specified classes. Can be used only with "use SOAP::Lite ..."
           clause and should be specified first:

             use SOAP::Lite
               dispatch_from => [‚ÄôA‚Äô, ‚ÄôB‚Äô], # use "dispatch_from => ‚ÄôA‚Äô" for one class
               uri => ....,
               proxy => ....,
             ;

             A‚Äê>a;
             B‚Äê>b;

       [1mSOAP::Data[0m

       You can use this class if you want to specify a value, a name, atype, a
       uri or attributes for SOAP elements (use "value()", "name()", "type()",
       "uri()" and "attr()" methods correspondingly).  For example,
       "SOAP::Data‚àí>name(‚Äôabc‚Äô)‚àí>value(123)" will be serialized into
       "<abc>123</abc>", as well as will "SOAP::Data‚àí>name(abc => 123)".  Each
       of them (except the [4mvalue()[24m method) can accept a value as the second
       parameter. All methods return the current value if you call them with‚Äê
       out parameters. The return the object otherwise, so you can stack them.
       See tests for more examples. You can import these methods with:

         SOAP::Data‚Äê>import(‚Äôname‚Äô);

       or

         import SOAP::Data ‚Äôname‚Äô;

       and then use "name(abc => 123)" for brevity.

       An interface for specific attributes is also provided. You can use the
       "actor()", "mustUnderstand()", "encodingStyle()" and "root()" methods
       to set/get values of the correspondent attributes.

         SOAP::Data
           ‚Äê>name(c => 3)
           ‚Äê>encodingStyle(‚Äôhttp://xml.apache.org/xml‚Äêsoap/literalxml‚Äô)

       will be serialized into:

         <c SOAP‚ÄêENV:encodingStyle="http://xml.apache.org/xml‚Äêsoap/literalxml"
            xsi:type="xsd:int">3</c>

       [1mSOAP::Serializer[0m

       Usually you don‚Äôt need to interact directly with this module. The only
       case when you need it, it when using autotyping. This feature lets you
       specify types for your data according to your needs as well as to
       introduce new data types (like ordered hash for example).

       You can specify a type with "SOAP::Data‚àí>type(float => 123)". During
       the serialization stage the module will try to serialize your data with
       the "as_float" method. It then calls the "typecast" method (you can
       override it or inherit your own class from "SOAP::Data") and only then
       it will try to serialize it according to data type ("SCALAR", "ARRAY"
       or "HASH"). For example:

         SOAP::Data‚Äê>type(‚Äôordered_hash‚Äô => [a => 1, b => 2])

       will be serialized as an ordered hash, using the "as_ordered_hash"
       method.

       If you do not specify a type directly, the serialization module will
       try to autodefine the type for you according to the "typelookup" hash.
       It contains the type name as key and the following 3‚àíelement array as
       value:

         priority,
         check_function (CODE reference),
         typecast function (METHOD name or CODE reference)

       For example, if you want to add "uriReference" to autodefined types,
       you should add something like this:

         $s‚Äê>typelookup‚Äê>{uriReference} =
           [11, sub { $_[0] =~ m!^http://! }, ‚Äôas_uriReference‚Äô];

       and add the "as_uriReference" method to the "SOAP::Serializer" class:

         sub SOAP::Serializer::as_uriReference {
           my $self = shift;
           my($value, $name, $type, $attr) = @_;
           return [$name, {‚Äôxsi:type‚Äô => ‚Äôxsd:uriReference‚Äô, %$attr}, $value];
         }

       The specified methods will work for both autotyping and direct typing,
       so you can use either

         SOAP::Data‚Äê>type(uriReference => ‚Äôhttp://yahoo.com‚Äô)>

       or just

         ‚Äôhttp://yahoo.com‚Äô

       and it will be serialized into the same type. For more examples see
       "as_*" methods in "SOAP::Serializer".

       The SOAP::Serializer provides you with "autotype()", "readable()",
       "namespace()", "encodingspace()", "encoding()", "typelookup()",
       "uri()", "multirefinplace()" and "envelope()" methods. All methods
       (except "envelope()") are described in the "SOAP::Lite" section.

       [4menvelope()[0m
           This method allows you to build three kind of envelopes depending
           on the first parameter:

           method
                 envelope(method => ‚Äômethodname‚Äô, @parameters);

               or

                 method(‚Äômethodname‚Äô, @parameters);

               Lets you build a request/response envelope.

           fault
                 envelope(fault => ‚Äôfaultcode‚Äô, ‚Äôfaultstring‚Äô, $details);

               or

                 fault(‚Äôfaultcode‚Äô, ‚Äôfaultstring‚Äô, $details);

               Lets you build a fault envelope. Faultcode will be properly
               qualified and details could be string or object.

           freeform
                 envelope(freeform => ‚Äôsomething that I want to serialize‚Äô);

               or

                 freeform(‚Äôsomething that I want to serialize‚Äô);

               Reserved for nonRPC calls. Lets you build your own payload
               inside a SOAP envelope. All SOAP 1.1 specification rules are
               enforced, except method specific ones. See UDDI::Lite as exam‚Äê
               ple.

       For more examples see tests and SOAP::Transport::HTTP.pm

       [1mSOAP::SOM[0m

       All calls you are making through object oriented interface will return
       SOAP::SOM object, and you can access actual values with it.  Next exam‚Äê
       ple gives you brief overview of the class:

         my $soap = SOAP::Lite .....;
         my $som = $soap‚Äê>method(@parameters);

         if ($som‚Äê>fault) { # will be defined if Fault element is in the message
           print $som‚Äê>faultdetail; # returns value of ‚Äôdetail‚Äô element as
                                    # string or object
           $som‚Äê>faultcode;   #
           $som‚Äê>faultstring; # also available
           $som‚Äê>faultactor;  #
         } else {
           $som‚Äê>result; # gives you access to result of call
                         # it could be any data structure, for example reference
                         # to array if server didi something like: return [1,2];

           $som‚Äê>paramsout; # gives you access to out parameters if any
                            # for example, you‚Äôll get array (1,2) if
                            # server returns ([1,2], 1, 2);
                            # [1,2] will be returned as $som‚Äê>result
                            # and $som‚Äê>paramsall will return ([1,2], 1, 2)
                            # see section IN/OUT, OUT PARAMETERS AND AUTOBINDING
                            # for more information

           $som‚Äê>paramsall; # gives access to result AND out parameters (if any)
                            # and returns them as one array

           $som‚Äê>valueof(‚Äô//myelement‚Äô); # returns value(s) (as perl data) of
                                         # ‚Äômyelement‚Äô if any. All elements in array
                                         # context and only first one in scalar

           $h = $som‚Äê>headerof(‚Äô//myheader‚Äô); # returns element as SOAP::Header, so
                                              # you can access attributes and values
                                              # with $h‚Äê>mustUnderstand, $h‚Äê>actor
                                              # or $h‚Äê>attr (for all attributes)
         }

       SOAP::SOM object gives you access to the deserialized envelope via sev‚Äê
       eral methods. All methods accept a node path (similar to XPath nota‚Äê
       tions).  SOM interprets ‚Äô/‚Äô as the root node, ‚Äô//‚Äô as relative location
       path (‚Äô//Body‚Äô will find all bodies in document, as well as ‚Äô/Enve‚Äê
       lope//nums‚Äô will find all ‚Äônums‚Äô nodes under Envelope node), ‚Äô[num]‚Äô as
       node number and ‚Äô[op num]‚Äô with "op" being a comparison operator (‚Äô<‚Äô,
       ‚Äô>‚Äô, ‚Äô<=‚Äô, ‚Äô>=‚Äô, ‚Äô!‚Äô, ‚Äô=‚Äô).

       All nodes in nodeset will be returned in document order.

       [4mmatch()[0m
           Accepts a path to a node and returns true/false in a boolean con‚Äê
           text and a SOM object otherwise. "valueof()" and "dataof()" can be
           used to get value(s) of matched node(s).

       [4mvalueof()[0m
           Returns the value of a (previously) matched node. It accepts a node
           path.  In this case, it returns the value of matched node, but does
           not change the current node. Suitable when you want to match a
           node and then navigate through node children:

             $som‚Äê>match(‚Äô/Envelope/Body/[1]‚Äô); # match method
             $som‚Äê>valueof(‚Äô[1]‚Äô);              # result
             $som‚Äê>valueof(‚Äô[2]‚Äô);              # first out parameter (if present)

           The returned value depends on the context. In a scalar context it
           will return the first element from matched nodeset. In an array
           context it will return all matched elements.

       [4mdataof()[0m
           Same as "valueof()", but it returns a "SOAP::Data" object, so you
           can get access to the name, the type and attributes of an element.

       [4mheaderof()[0m
           Same as "dataof()", but it returns "SOAP::Header" object, so you
           can get access to the name, the type and attributes of an element.
           Can be used for modifying headers (if you want to see updated
           header inside Header element, it‚Äôs better to use this method
           instead of "dataof()" method).

       [4mnamespaceuriof()[0m
           Returns the uri associated with the matched element. This uri can
           also be inherited, for example, if you have

             <a xmlns=‚Äôhttp://my.namespace‚Äô>
               <b>
                  value
               </b>
             </a>

           this method will return same value for ‚Äôb‚Äô element as for ‚Äôa‚Äô.

       SOAP::SOM also provides  methods for direct access to the envelope, the
       body, methods and parameters (both in and out). All these methods
       return real values (in most cases it will be a hash reference), if
       called as object method. Returned values also depend on context: in an
       array context it will return an array of values and in scalar context
       it will return the first element. So, if you want to access the first
       output parameter, you can call "$param = $som‚àí>paramsout"; and you will
       get it regardless of the actual number of output parameters.  If you
       call it as class function (for example, SOAP::SOM::method) it returns
       an XPath string that matches the current element (‚Äô/Envelope/Body/[1]‚Äô
       in case of ‚Äômethod‚Äô). The method will return "undef" if not present OR
       if you try to access an undefined element. To distinguish between these
       two cases you can first access the "match()" method that will return
       true/false in a boolean context and then get the real value:

         if ($som‚Äê>match(‚Äô//myparameter‚Äô)) {
           $value = $som‚Äê>valueof; # can be undef too
         } else {
           # doesn‚Äôt exist
         }

       [4mroot()[0m
           Returns the value (as hash) of the root element. Do exactly the
           same as "$som‚àí>valueof(‚Äô/‚Äô)" does.

       [4menvelope()[0m
           Returns the value (as hash) of the "Envelope" element. Keys in this
           hash will be ‚ÄôHeader‚Äô (if present), ‚ÄôBody‚Äô and any other (optional)
           elements. Values will be the deserialized header, body, and ele‚Äê
           ments, respectively.  If called as function ("SOAP::SOM::envelope")
           it will return a Xpath string that matches the envelope content.
           Useful when you want just match it and then iterate over the con‚Äê
           tent by yourself. Example:

             if ($som‚Äê>match(SOAP::SOM::envelope)) {
               $som‚Äê>valueof(‚ÄôHeader‚Äô); # should give access to header if present
               $som‚Äê>valueof(‚ÄôBody‚Äô);   # should give access to body
             } else {
               # hm, are we doing SOAP or what?
             }

       [4mheader()[0m
           Returns the value (as hash) of the "Header" element. If you want to
           access all attributes in the header use:

             # get element as SOAP::Data object
             $transaction = $som‚Äê>match(join ‚Äô/‚Äô, SOAP::SOM::header, ‚Äôtransaction‚Äô)‚Äê>dataof;
             # then you can access all attributes of ‚Äôtransaction‚Äô element
             $transaction‚Äê>attr;

       [4mheaders()[0m
           Returns a node set of values with deserialized headers. The differ‚Äê
           ence between the "header()" and "headers()" methods is that the
           first gives you access to the whole header and second to the head‚Äê
           ers inside the ‚ÄôHeader‚Äô tag:

             $som‚Äê>headerof(join ‚Äô/‚Äô, SOAP::SOM::header, ‚Äô[1]‚Äô);
             # gives you first header as SOAP::Header object

             ($som‚Äê>headers)[0];
             # gives you value of the first header, same as
             $som‚Äê>valueof(join ‚Äô/‚Äô, SOAP::SOM::header, ‚Äô[1]‚Äô);

             $som‚Äê>header‚Äê>{name_of_your_header_here}
             # gives you value of name_of_your_header_here

       [4mbody()[0m
           Returns the value (as hash) of the "Body" element.

       [4mfault()[0m
           Returns the value (as hash) of "Fault" element: "faultcode",
           "faultstring" and "detail". If "Fault" element is present,
           "result()", "paramsin()", "paramsout()" and "method()" will return
           an undef.

       [4mfaultcode()[0m
           Returns the value of the "faultcode" element if present and undef
           otherwise.

       [4mfaultstring()[0m
           Returns the value of the "faultstring" element if present and undef
           otherwise.

       [4mfaultactor()[0m
           Returns the value of the "faultactor" element if present and undef
           otherwise.

       [4mfaultdetail()[0m
           Returns the value of the "detail" element if present and undef oth‚Äê
           erwise.

       [4mmethod()[0m
           Returns the value of the method element (all input parameters if
           you call it on a deserialized request envelope, and result/output
           parameters if you call it on a deserialized response envelope).
           Returns undef if the ‚ÄôFault‚Äô element is present.

       [4mresult()[0m
           Returns the value of the "result" of the method call. In fact, it
           will return the first child element (in document order) of the
           method element.

       [4mparamsin()[0m
           Returns the value(s) of all passed parameters.

       [4mparamsout()[0m
           Returns value(s) of the output parameters.

       [4mparamsall()[0m
           Returns value(s) of the result AND output parameters as one array.

       [1mSOAP::Schema[0m

       SOAP::Schema gives you ability to load schemas and create stubs accord‚Äê
       ing to these schemas. Different syntaxes are provided:

       ¬∑
             use SOAP::Lite
               service => ‚Äôhttp://www.xmethods.net/sd/StockQuoteService.wsdl‚Äô,
               # service => ‚Äôfile:/your/local/path/StockQuoteService.wsdl‚Äô,
               # service => ‚Äôfile:./StockQuoteService.wsdl‚Äô,
             ;
             print getQuote(‚ÄôMSFT‚Äô), "\n";

       ¬∑
             use SOAP::Lite;
             print SOAP::Lite
               ‚Äê> service(‚Äôhttp://www.xmethods.net/sd/StockQuoteService.wsdl‚Äô)
               ‚Äê> getQuote(‚ÄôMSFT‚Äô), "\n";

       ¬∑
             use SOAP::Lite;
             my $service = SOAP::Lite
               ‚Äê> service(‚Äôhttp://www.xmethods.net/sd/StockQuoteService.wsdl‚Äô);
             print $service‚Äê>getQuote(‚ÄôMSFT‚Äô), "\n";

       You can create stub with [1mstubmaker [22mscript:

         perl stubmaker.pl http://www.xmethods.net/sd/StockQuoteService.wsdl

       and you‚Äôll be able to access SOAP services in one line:

         perl "‚ÄêMStockQuoteService qw(:all)" ‚Äêle "print getQuote(‚ÄôMSFT‚Äô)"

       or dynamically:

         perl "‚ÄêMSOAP::Lite service=>‚Äôfile:./quote.wsdl‚Äô" ‚Äêle "print getQuote(‚ÄôMSFT‚Äô)"

       Other supported syntaxes with stub(s) are:

       ¬∑
             use StockQuoteService ‚Äô:all‚Äô;
             print getQuote(‚ÄôMSFT‚Äô), "\n";

       ¬∑
             use StockQuoteService;
             print StockQuoteService‚Äê>getQuote(‚ÄôMSFT‚Äô), "\n";

       ¬∑
             use StockQuoteService;
             my $service = StockQuoteService‚Äê>new;
             print $service‚Äê>getQuote(‚ÄôMSFT‚Äô), "\n";

       Support for schemas is limited for now. Though module was tested with
       dozen different schemas it won‚Äôt understand complex objects and will
       work only with WSDL.

       [1mSOAP::Trace[0m

       SOAP::Trace provides you with a trace/debug facility for the SOAP::Lite
       library. To activate it you need to specify a list of traceable
       events/parts of SOAP::Lite:

         use SOAP::Lite +trace =>
           qw(list of available traces here);

       Available events are:

        transport  ‚Äê‚Äê (client) access to request/response for transport layer
        dispatch   ‚Äê‚Äê (server) shows full name of dispatched call
        result     ‚Äê‚Äê (server) result of method call
        parameters ‚Äê‚Äê (server) parameters for method call
        headers    ‚Äê‚Äê (server) headers of received message
        objects    ‚Äê‚Äê (both)   new/DESTROY calls
        method     ‚Äê‚Äê (both)   parameters for ‚Äô‚Äê>envelope(method =>‚Äô call
        fault      ‚Äê‚Äê (both)   parameters for ‚Äô‚Äê>envelope(fault =>‚Äô call
        freeform   ‚Äê‚Äê (both)   parameters for ‚Äô‚Äê>envelope(freeform =>‚Äô call
        trace      ‚Äê‚Äê (both)   trace enters into some important functions
        debug      ‚Äê‚Äê (both)   details about transport

       For example:

         use SOAP::Lite +trace =>
           qw(method fault);

       lets you output the parameter values for all your fault/normal
       envelopes onto STDERR.  If you want to log it you can either redirect
       STDERR to some file

         BEGIN { open(STDERR, ‚Äô>>....‚Äô); }

       or (preferably) define your own function for a particular event:

         use SOAP::Lite +trace =>
           method => sub {‚Äôlog messages here‚Äô}, fault => \&log_faults;

       You can share the same function for several events:

         use SOAP::Lite +trace =>
           method, fault => \&log_methods_and_faults;

       Also you can use ‚Äôall‚Äô to get all available tracing and use ‚Äô‚àí‚Äô in
       front of an event to disable particular event:

         use SOAP::Lite +trace =>
           all, ‚Äêtransport; # to get all logging without transport messages

       Finally,

         use SOAP::Lite +trace;

       will switch all debugging on.

       You can use ‚Äôdebug‚Äô instead of ‚Äôtrace‚Äô. I prefer ‚Äôtrace‚Äô, others
       ‚Äôdebug‚Äô.  Also "on_debug" is available for backward compatibility, as
       in

         use SOAP::Lite;

         my $s = SOAP::Lite
           ‚Äê> uri(‚Äôhttp://tempuri.org/‚Äô)
           ‚Äê> proxy(‚Äôhttp://beta.search.microsoft.com/search/MSComSearchService.asmx‚Äô)
           ‚Äê> on_debug(sub{print@_}) # show you request/response with headers
         ;
         print $s‚Äê>GetVocabulary(SOAP::Data‚Äê>name(Query => ‚Äôsomething‚Äô)‚Äê>uri(‚Äôhttp://tempuri.org/‚Äô))
                 ‚Äê>valueof(‚Äô//FOUND‚Äô);

       or switch it on individually, with

         use SOAP::Lite +trace => debug;

       or

         use SOAP::Lite +trace => debug => sub {‚Äôdo_what_I_want_here‚Äô};

       Compare this with:

         use SOAP::Lite +trace => transport;

       which gives you access to [1mactual [22mrequest/response objects, so you can
       even set/read cookies or do whatever you want there.

       The difference between "debug" and "transport" is that "transport" will
       get a HTTP::Request/HTTP::Response object and "debug" will get a
       stringified request (NOT OBJECT!). It can also be called in other
       places too.

       [1mSOAP::Fault[0m

       This class gives you access to Fault generated on server side. To make
       a Fault message you might simply die on server side and SOAP processor
       will wrap you message as faultstring element and will transfer Fault on
       client side. But in some cases you need to have more control over this
       process and SOAP::Fault class gives it to you. To use it, simply die
       with SOAP::Fault object as a parameter:

         die SOAP::Fault‚Äê>faultcode(‚ÄôServer.Custom‚Äô) # will be qualified
                        ‚Äê>faultstring(‚ÄôDied in server method‚Äô)
                        ‚Äê>faultdetail(bless {code => 1} => ‚ÄôBadError‚Äô)
                        ‚Äê>faultactor(‚Äôhttp://www.soaplite.com/custom‚Äô);

       [4mfaultdetail()[24m and [4mfaultactor()[24m methods are optional and since faultcode
       and faultstring are required to represent fault message SOAP::Lite will
       use default values (‚ÄôServer‚Äô and ‚ÄôApplication error‚Äô) if not specified.

       [1mSOAP::Constants[0m

       This class gives you access to number of options that may affect behav‚Äê
       ior of SOAP::Lite objects. They are not true contstants, aren‚Äôt they?

       $DO_NOT_USE_XML_PARSER
           By default SOAP::Lite tries to load XML::Parser and if it fails,
           then to load XML::Parser::Lite. You may skip the first step and use
           XML::Parser::Lite even if XML::Parser is presented in your system
           if assign true value like this:

             $SOAP::Constants::DO_NOT_USE_XML_PARSER = 1;

       $DO_NOT_USE_CHARSET
           By default SOAP::Lite specifies charset in content‚àítype. Since not
           every toolkit likes it you have an option to switch it off if you
           set $DO_NOT_USE_CHARSET to true.

       $DO_NOT_CHECK_CONTENT_TYPE
           By default SOAP::Lite verifies that content‚Äêtype in successful
           response has value ‚Äômultipart/related‚Äô or ‚Äômultipart/form‚àídata‚Äô for
           MIME‚Äêencoded messages and ‚Äôtext/xml‚Äô for all other ocassions.
           SOAP::Lite will raise exception for all other values.
           $DO_NOT_CHECK_CONTENT_TYPE when set to true will allow you to
           accept those values as valid.

[1mFEATURES AND OPTIONS[0m
       [1mDEFAULT SETTINGS[0m

       Though this feature looks similar to autodispatch they have (almost)
       nothing in common. It lets you create default object and all objects
       created after that will be cloned from default object and hence get its
       properties. If you want to provide common [4mproxy()[24m or [4muri()[24m settings for
       all SOAP::Lite objects in your application you may do:

         use SOAP::Lite
           proxy => ‚Äôhttp://localhost/cgi‚Äêbin/soap.cgi‚Äô,
           uri => ‚Äôhttp://my.own.com/My/Examples‚Äô
         ;

         my $soap1 = new SOAP::Lite; # will get the same proxy()/uri() as above
         print $soap1‚Äê>getStateName(1)‚Äê>result;

         my $soap2 = SOAP::Lite‚Äê>new; # same thing as above
         print $soap2‚Äê>getStateName(2)‚Äê>result;

         # or you may override any settings you want
         my $soap3 = SOAP::Lite‚Äê>proxy(‚Äôhttp://localhost/‚Äô);
         print $soap3‚Äê>getStateName(1)‚Äê>result;

       [1mAny [22mSOAP::Lite properties can be propagated this way. Changes in object
       copies will not affect global settings and you may still change global
       settings with "SOAP::Lite‚àí>self" call which returns reference to global
       object. Provided parameter will update this object and you can even set
       it to "undef":

         SOAP::Lite‚Äê>self(undef);

       The "use SOAP::Lite" syntax also lets you specify default event han‚Äê
       dlers for your code. If you have different SOAP objects and want to
       share the same "on_action()" (or "on_fault()" for that matter) handler.
       You can specify "on_action()" during initialization for every object,
       but you may also do:

         use SOAP::Lite
           on_action => sub {sprintf ‚Äô%s#%s‚Äô, @_}
         ;

       and this handler will be the default handler for all your SOAP objects.
       You can override it if you specify a handler for a particular object.
       See [4mt/*.t[24m for example of [4mon_fault()[24m handler.

       Be warned, that since "use ..." is executed at compile time [1mall [22m"use"
       statements will be executed [1mbefore [22mscript execution that can make unex‚Äê
       pected results. Consider code:

         use SOAP::Lite proxy => ‚Äôhttp://localhost/‚Äô;

         print SOAP::Lite‚Äê>getStateName(1)‚Äê>result;

         use SOAP::Lite proxy => ‚Äôhttp://localhost/cgi‚Äêbin/soap.cgi‚Äô;

         print SOAP::Lite‚Äê>getStateName(1)‚Äê>result;

       [1mBOTH [22mSOAP calls will go to ‚Äôhttp://localhost/cgi‚àíbin/soap.cgi‚Äô. If you
       want to execute "use" at run‚àítime, put it in "eval":

         eval "use SOAP::Lite proxy => ‚Äôhttp://localhost/cgi‚Äêbin/soap.cgi‚Äô; 1" or die;

       or use

         SOAP::Lite‚Äê>self‚Äê>proxy(‚Äôhttp://localhost/cgi‚Äêbin/soap.cgi‚Äô);

       [1mIN/OUT, OUT PARAMETERS AND AUTOBINDING[0m

       SOAP::Lite gives you access to all parameters (both in/out and out) and
       also does some additional work for you. Lets consider following exam‚Äê
       ple:

         <mehodResponse>
           <res1>name1</res1>
           <res2>name2</res2>
           <res3>name3</res3>
         </mehodResponse>

       In that case:

         $result = $r‚Äê>result; # gives you ‚Äôname1‚Äô
         $paramout1 = $r‚Äê>paramsout;      # gives you ‚Äôname2‚Äô, because of scalar context
         $paramout1 = ($r‚Äê>paramsout)[0]; # gives you ‚Äôname2‚Äô also
         $paramout2 = ($r‚Äê>paramsout)[1]; # gives you ‚Äôname3‚Äô

       or

         @paramsout = $r‚Äê>paramsout; # gives you ARRAY of out parameters
         $paramout1 = $paramsout[0]; # gives you ‚Äôres2‚Äô, same as ($r‚Äê>paramsout)[0]
         $paramout2 = $paramsout[1]; # gives you ‚Äôres3‚Äô, same as ($r‚Äê>paramsout)[1]

       Generally, if server returns "return (1,2,3)" you will get 1 as the
       result and 2 and 3 as out parameters.

       If the server returns "return [1,2,3]" you will get an ARRAY from
       "result()" and "undef" from "paramsout()" .  Results can be arbitrary
       complex: they can be an array of something, they can be objects, they
       can be anything and still be returned by "result()" . If only one
       parameter is returned, "paramsout()" will return "undef".

       But there is more.  If you have in your output parameters a parameter
       with the same signature (name+type) as in the input parameters this
       parameter will be mapped into your input automatically. Example:

       [1mserver[22m:

         sub mymethod {
           shift; # object/class reference
           my $param1 = shift;
           my $param2 = SOAP::Data‚Äê>name(‚Äômyparam‚Äô => shift() * 2);
           return $param1, $param2;
         }

       [1mclient[22m:

         $a = 10;
         $b = SOAP::Data‚Äê>name(‚Äômyparam‚Äô => 12);
         $result = $soap‚Äê>mymethod($a, $b);

       After that, "$result == 10 and $b‚àí>value == 24"! Magic? Sort of.  Auto‚Äê
       binding gives it to you. That will work with objects also with one dif‚Äê
       ference: you do not need to worry about the name and the type of object
       parameter. Consider the "PingPong" example ([4mexamples/My/PingPong.pm[24m and
       [4mexamples/pingpong.pl[24m):

       [1mserver[22m:

         package My::PingPong;

         sub new {
           my $self = shift;
           my $class = ref($self) ‚îÇ‚îÇ $self;
           bless {_num=>shift} => $class;
         }

         sub next {
           my $self = shift;
           $self‚Äê>{_num}++;
         }

       [1mclient[22m:

         use SOAP::Lite +autodispatch =>
           uri => ‚Äôurn:‚Äô,
           proxy => ‚Äôhttp://localhost/‚Äô
         ;

         my $p = My::PingPong‚Äê>new(10); # $p‚Äê>{_num} is 10 now, real object returned
         print $p‚Äê>next, "\n";          # $p‚Äê>{_num} is 11 now!, object autobinded

       [1mAUTODISPATCHING AND SOAP:: PREFIX[0m

       [1mWARNING[22m: "autodispatch" feature can have side effects for your applica‚Äê
       tion and can affect functionality of other modules/libraries because of
       overloading UNIVERSAL::AUTOLOAD. All unresolved calls will be dis‚Äê
       patched as SOAP calls, however it could be not what you want in some
       cases. If so, consider using object interface (see "implementation of
       OO interface").

       SOAP::Lite provides an autodispatching feature that lets you create
       code which looks the same for local and remote access.

       For example:

         use SOAP::Lite +autodispatch =>
           uri => ‚Äôurn:/My/Examples‚Äô,
           proxy => ‚Äôhttp://localhost/‚Äô
         ;

       tells SOAP to ‚Äôautodispatch‚Äô all calls to the ‚Äôhttp://localhost/‚Äô end‚Äê
       point with the ‚Äôurn:/My/Examples‚Äô uri. All consequent method calls can
       look like:

         print getStateName(1), "\n";
         print getStateNames(12,24,26,13), "\n";
         print getStateList([11,12,13,42])‚Äê>[0], "\n";
         print getStateStruct({item1 => 10, item2 => 4})‚Äê>{item2}, "\n";

       As you can see, there is no SOAP specific coding at all.

       The same logic will work for objects as well:

         print "Session iterator\n";
         my $p = My::SessionIterator‚Äê>new(10);
         print $p‚Äê>next, "\n";
         print $p‚Äê>next, "\n";

       This will access the remote My::SessionIterator module, gets an object,
       and then calls remote methods again. The object will be transferred to
       the server, the method is executed there and the result (and the modi‚Äê
       fied object!) will be transferred back to the client.

       Autodispatch will work [1monly [22mif you do not have the same method in your
       code. For example, if you have "use My::SessionIterator" somewhere in
       your code of our previous example, all methods will be resolved locally
       and no SOAP calls will be done. If you want to get access to remote
       objects/methods even in that case, use "SOAP::" prefix to your methods,
       like:

         print $p‚Äê>SOAP::next, "\n";

       See "pingpong.pl" for example of a script, that works with the same
       object locally and remotely.

       "SOAP::" prefix also gives you ability to access methods that have the
       same name as methods of SOAP::Lite itself. For example, you want to
       call method [4mnew()[24m for your class "My::PingPong" through OO interface.
       First attempt could be:

         my $s = SOAP::Lite
           ‚Äê> uri(‚Äôhttp://www.soaplite.com/My/PingPong‚Äô)
           ‚Äê> proxy(‚Äôhttp://localhost/cgi‚Äêbin/soap.cgi‚Äô)
         ;
         my $obj = $s‚Äê>new(10);

       but it won‚Äôt work, because SOAP::Lite has method [4mnew()[24m itself. To pro‚Äê
       vide a hint, you should use "SOAP::" prefix and call will be dispatched
       remotely:

         my $obj = $s‚Äê>SOAP::new(10);

       You can mix autodispatch and usual SOAP calls in the same code if you
       need it. Keep in mind, that calls with SOAP:: prefix should always be a
       method call, so if you want to call functions, use "SOAP‚àí>myfunction()"
       instead of "SOAP::myfunction()".

       Be warned though Perl has very flexible syntax some versions will com‚Äê
       plain

         Bareword "autodispatch" not allowed while "strict subs" in use ...

       if you try to put ‚Äôautodispatch‚Äô and ‚Äô=>‚Äô on separate lines. So, keep
       them on the same line, or put ‚Äôautodispatch‚Äô in quotes:

         use SOAP::Lite ‚Äôautodispatch‚Äô # DON‚ÄôT use plus in this case
           => ....
         ;

       [1mACCESSING HEADERS AND ENVELOPE ON SERVER SIDE[0m

       SOAP::Lite gives you direct access to all headers and the whole enve‚Äê
       lope on the server side. Consider the following code from My::Parame‚Äê
       ters.pm:

         sub byname {
           my($a, $b, $c) = @{pop‚Äê>method}{qw(a b c)};
           return "a=$a, b=$b, c=$c";
         }

       You will get this functionality ONLY if you inherit your class from the
       SOAP::Server::Parameters class. This should keep existing code working
       and provides this feature only when you need it.

       Every method on server side will be called as class/object method, so
       it will get an [1mobject reference [22mor a [1mclass name [22mas the first parameter,
       then the method parameters, and then an envelope as SOAP::SOM object.
       Shortly:

         $self [, @parameters] , $envelope

       If you have a fixed number of parameters, you can do:

         my $self = shift;
         my($param1, $param2) = @_;

       and ignore the envelope. If you need access to the envelope you can do:

         my $envelope = pop;

       since the envelope is always the last element in the parameters list.
       The "byname()" method "pop‚àí>method" will return a hash with parameter
       names as hash keys and parameter values as hash values:

         my($a, $b, $c) = @{pop‚Äê>method}{qw(a b c)};

       gives you by‚Äêname access to your parameters.

       [1mSERVICE DEPLOYMENT. STATIC AND DYNAMIC[0m

       Let us scrutinize the deployment process. When designing your SOAP
       server you can consider two kind of deployment: [1mstatic [22mand [1mdynamic[22m.
       For both, static and dynamic,  you should specify "MODULE", "MOD‚Äê
       ULE::method", "method" or "PATH/" when creating "use"ing the SOAP::Lite
       module. The difference between static and dynamic deployment is that in
       case of ‚Äôdynamic‚Äô, any module which is not present will be loaded on
       demand. See the "SECURITY" section for detailed description.

       Example for [1mstatic [22mdeployment:

         use SOAP::Transport::HTTP;
         use My::Examples;           # module is preloaded

         SOAP::Transport::HTTP::CGI
           # deployed module should be present here or client will get ‚Äôaccess denied‚Äô
           ‚Äê> dispatch_to(‚ÄôMy::Examples‚Äô)
           ‚Äê> handle;

       Example for [1mdynamic [22mdeployment:

         use SOAP::Transport::HTTP;
         # name is unknown, module will be loaded on demand

         SOAP::Transport::HTTP::CGI
           # deployed module should be present here or client will get ‚Äôaccess denied‚Äô
           ‚Äê> dispatch_to(‚Äô/Your/Path/To/Deployed/Modules‚Äô, ‚ÄôMy::Examples‚Äô)
           ‚Äê> handle;

       For static deployment you should specify the MODULE name directly.  For
       dynamic deployment you can specify the name either directly (in that
       case it will be "require"d without any restriction) or indirectly, with
       a PATH In that case, the ONLY path that will be available will be the
       PATH given to the [4mdispatch_to()[24m method). For information how to handle
       this situation see "SECURITY" section.

       You should also use static binding when you have several different
       classes in one file and want to make them available for SOAP calls.

       [1mSUMMARY[22m:

         dispatch_to(
           # dynamic dispatch that allows access to ALL modules in specified directory
           PATH/TO/MODULES
           # 1. specifies directory
           # ‚Äê‚Äê AND ‚Äê‚Äê
           # 2. gives access to ALL modules in this directory without limits

           # static dispatch that allows access to ALL methods in particular MODULE
           MODULE
           #  1. gives access to particular module (all available methods)
           #  PREREQUISITES:
           #    module should be loaded manually (for example with ‚Äôuse ...‚Äô)
           #    ‚Äê‚Äê OR ‚Äê‚Äê
           #    you can still specify it in PATH/TO/MODULES

           # static dispatch that allows access to particular method ONLY
           MODULE::method
           # same as MODULE, but gives access to ONLY particular method,
           # so there is not much sense to use both MODULE and MODULE::method
           # for the same MODULE
         )

       In addition to this SOAP::Lite also supports experimental syntax that
       allows you bind specific URL or SOAPAction to CLASS/MODULE or object:

         dispatch_with({
           URI => MODULE,        # ‚Äôhttp://www.soaplite.com/‚Äô => ‚ÄôMy::Class‚Äô,
           SOAPAction => MODULE, # ‚Äôhttp://www.soaplite.com/method‚Äô => ‚ÄôAnother::Class‚Äô,
           URI => object,        # ‚Äôhttp://www.soaplite.com/obj‚Äô => My::Class‚Äê>new,
         })

       URI is checked before SOAPAction. You may use both "dispatch_to()" and
       "dispatch_with()" syntax and "dispatch_with()" has more priority, so
       first checked URI, then SOAPAction and only then will be checked "dis‚Äê
       patch_to()". See [4mt/03‚àíserver.t[24m for more information and examples.

       [1mSECURITY[0m

       Due to security reasons, the current path for perl modules (@INC) will
       be disabled once you have chosen dynamic deployment and specified your
       own "PATH/".  If you want to access other modules in your included
       package you have several options:

       1   Switch to static linking:

              use MODULE;
              $server‚Äê>dispatch_to(‚ÄôMODULE‚Äô);

           It can be useful also when you want to import something specific
           from the deployed modules:

              use MODULE qw(import_list);

       2   Change "use" to "require". The path is unavailable only during the
           initialization part, and it is available again during execution.
           So, if you do "require" somewhere in your package, it will work.

       3   Same thing, but you can do:

              eval ‚Äôuse MODULE qw(import_list)‚Äô; die if $@;

       4   Assign a @INC directory in your package and then make "use".  Don‚Äôt
           forget to put @INC in "BEGIN{}" block or it won‚Äôt work:

              BEGIN { @INC = qw(my_directory); use MODULE }

       [1mCOMPRESSION[0m

       SOAP::Lite provides you option for enabling compression on wire (for
       HTTP transport only). Both server and client should support this capa‚Äê
       bility, but this logic should be absolutely transparent for your appli‚Äê
       cation.

       Compression can be enabled by specifying threshold for compression on
       client or server side:

       Client
             print SOAP::Lite
               ‚Äê> uri(‚Äôhttp://localhost/My/Parameters‚Äô)
               ‚Äê> proxy(‚Äôhttp://localhost/‚Äô, options => {compress_threshold => 10000})
               ‚Äê> echo(1 x 10000)
               ‚Äê> result
             ;

       Server
             my $server = SOAP::Transport::HTTP::CGI
               ‚Äê> dispatch_to(‚ÄôMy::Parameters‚Äô)
               ‚Äê> options({compress_threshold => 10000})
               ‚Äê> handle;

       For more information see COMPRESSION section in HTTP transport documen‚Äê
       tation.

       [1mOBJECTS‚ÄêBY‚ÄêREFERENCE[0m

       SOAP::Lite implements an experimental (yet functional) support for
       objects‚àíby‚àíreference. You should not see any difference on the client
       side when using this. On the server side you should specify the names
       of the classes you want to be returned by reference (instead of by
       value) in the "objects_by_reference()" method for your server implemen‚Äê
       tation (see soap.pop3, soap.daemon and Apache.pm).

       Garbage collection is done on the server side (not earlier than after
       600 seconds of inactivity time), and you can overload the default
       behavior with specific functions for any particular class.

       Binding does not have any special syntax and is implemented on server
       side (see the differences between My::SessionIterator and My::Persis‚Äê
       tentIterator).  On the client side, objects will have same type/class
       as before ("My::SessionIterator‚àí>new()" will return an object of class
       My::SessionIterator). However, this object is just a stub with an
       object ID inside.

       [1mINTEROPERABILITY[0m


       Microsoft‚Äôs .NET
           To use .NET client and SOAP::Lite server

           qualify all elements
               use fully qualified names for your return values, e.g.:

                 return SOAP::Data‚Äê>name(‚Äômyname‚Äô)
                                  ‚Äê>type(‚Äôstring‚Äô)
                                  ‚Äê>uri(‚Äôhttp://tempuri.org/‚Äô)
                                  ‚Äê>value($output);

               Use namespace that you specify for URI instead of ‚Äôhttp://tem‚Äê
               puri.org/‚Äô.

               In addition see comment about default incoding in .NET Web Ser‚Äê
               vices below.

           To use SOAP::Lite client and .NET server

           declare proper soapAction (uri/method) in your call
               For example, use "on_action(sub{join ‚Äô‚Äô, @_})".

           disable charset in content‚Äêtype
               Specify "$SOAP::Constants::DO_NOT_USE_CHARSET = 1" somewhere in
               your code after "use SOAP::Lite" if you are getting error:

                 Server found request content type to be ‚Äôtext/xml; charset=utf‚Äê8‚Äô,
                 but expected ‚Äôtext/xml‚Äô

           qualify all elements
               Any of following actions should work:

               use fully qualified name for method parameters
                   Use "SOAP::Data‚àí>name(Query  =>
                   ‚Äôbiztalk‚Äô)‚àí>uri(‚Äôhttp://tempuri.org/‚Äô)" instead of
                   "SOAP::Data‚àí>name(‚ÄôQuery‚Äô  => ‚Äôbiztalk‚Äô)".

                   Example of SOAPsh call (all parameters should be in one
                   line):

                     > perl SOAPsh.pl
                       "http://beta.search.microsoft.com/search/mscomsearchservice.asmx"
                       "http://tempuri.org/"
                       "on_action(sub{join ‚Äô‚Äô, @_})"
                       "GetVocabulary(SOAP::Data‚Äê>name(Query  => ‚Äôbiztalk‚Äô)‚Äê>uri(‚Äôhttp://tempuri.org/‚Äô))"

               make method in default namespace
                   instead of

                     my @rc = $soap‚Äê>call(add => @parms)‚Äê>result;
                     # ‚Äê‚Äê OR ‚Äê‚Äê
                     my @rc = $soap‚Äê>add(@parms)‚Äê>result;

                   use

                     my $method = SOAP::Data‚Äê>name(‚Äôadd‚Äô)
                                            ‚Äê>attr({xmlns => ‚Äôhttp://tempuri.org/‚Äô});
                     my @rc = $soap‚Äê>call($method => @parms)‚Äê>result;

               modify .NET server if you are in charge for that
                   Stefan Pharies <stefanph@microsoft.com>:

                   SOAP::Lite uses the SOAP encoding (section 5 of the soap
                   1.1 spec), and the default for .NET Web Services is to use
                   a literal encoding. So elements in the request are unquali‚Äê
                   fied, but your service expects them to be qualified. .Net
                   Web Services has a way for you to change the expected mes‚Äê
                   sage format, which should allow you to get your interop
                   working.  At the top of your class in the asmx, add this
                   attribute (for Beta 1):

                     [SoapService(Style=SoapServiceStyle.RPC)]

                   Another source said it might be this attribute (for Beta
                   2):

                     [SoapRpcService]

                   Full Web Service text may look like:

                     <%@ WebService Language="C#" Class="Test" %>
                     using System;
                     using System.Web.Services;
                     using System.Xml.Serialization;

                     [SoapService(Style=SoapServiceStyle.RPC)]
                     public class Test : WebService {
                       [WebMethod]
                       public int add(int a, int b) {
                         return a + b;
                       }
                     }

                   Another example from Kirill Gavrylyuk <kir‚Äê
                   illg@microsoft.com>:

                   "You can insert [[4mSoapRpcService()[24m] attribute either on your
                   class or on operation level".

                     <%@ WebService Language=CS class="DataType.StringTest"%>

                     namespace DataType {

                       using System;
                       using System.Web.Services;
                       using System.Web.Services.Protocols;
                       using System.Web.Services.Description;

                      [SoapRpcService()]
                      public class StringTest: WebService {
                        [WebMethod]
                        [SoapRpcMethod()]
                        public string RetString(string x) {
                          return(x);
                        }
                      }
                    }

                   Example from Yann Christensen <yannc@microsoft.com>:

                     using System;
                     using System.Web.Services;
                     using System.Web.Services.Protocols;

                     namespace Currency {
                       [WebService(Namespace="http://www.yourdomain.com/example")]
                       [SoapRpcService]
                       public class Exchange {
                         [WebMethod]
                         public double getRate(String country, String country2) {
                           return 122.69;
                         }
                       }
                     }

           Thanks to
             Petr Janata <petr.janata@i.cz>,
             Stefan Pharies <stefanph@microsoft.com>,
             Brian Jepson <bjepson@jepstone.net>, and others for description
           and examples.

       [1mTROUBLESHOOTING[0m


       HTTP transport
           See TROUBLESHOOTING section in documentation for HTTP transport.

       COM interface
           Can‚Äôt call method "server" on undefined value
               Probably you didn‚Äôt register Lite.dll with ‚Äôregsvr32 Lite.dll‚Äô

           Failed to load PerlCtrl runtime
               Probably you have two Perl installations in different places
               and ActiveState‚Äôs Perl isn‚Äôt the first Perl specified in PATH.
               Rename the directory with another Perl (at least during the
               DLL‚Äôs startup) or put ActiveState‚Äôs Perl on the first place in
               PATH.

       XML Parsers
           SAX parsers
               SAX 2.0 has a known bug in org.xml.sax.helpers.ParserAdapter
                    rejects Namespace prefix used before declaration

               (http://www.megginson.com/SAX/index.html).

               That means that in some cases SOAP messages created by
               SOAP::Lite may not be parsed properly by SAX2/Java parser,
               because Envelope element contains namespace declarations and
               attributes that depends on this declarations. According to XML
               specification order of these attributes is not significant.
               SOAP::Lite does NOT have a problem parsing such messages.

               Thanks to Steve Alpert (Steve_Alpert@idx.com) for pointing on
               it.

       [1mPERFORMANCE[0m


       Processing of XML encoded fragments
           SOAP::Lite is based on XML::Parser which is basically wrapper
           around James Clark‚Äôs expat parser. Expat‚Äôs behavior for parsing XML
           encoded string can affect processing messages that have lot of
           encoded entities, like XML fragments, encoded as strings. Providing
           low‚Äêlevel details, parser will call [4mchar()[24m callback for every por‚Äê
           tion of processed stream, but individually for every processed
           entity or newline. It can lead to lot of calls and additional mem‚Äê
           ory manager expenses even for small messages. By contrast, XML mes‚Äê
           sages which are encoded as base64, don‚Äôt have this problem and dif‚Äê
           ference in processing time can be significant. For XML encoded
           string that has about 20 lines and 30 tags, number of call could be
           about 100 instead of one for the same string encoded as base64.

           Since it is parser‚Äôs feature there is NO fix for this behavior (let
           me know if you find one), especially because you need to parse mes‚Äê
           sage you already got (and you cannot control content of this mes‚Äê
           sage), however, if your are in charge for both ends of processing
           you can switch encoding to base64 on sender‚Äôs side. It will defi‚Äê
           nitely work with SOAP::Lite and it [1mmay [22mwork with other toolk‚Äê
           its/implementations also, but obviously I cannot guarantee that.

           If you want to encode specific string as base64, just do
           "SOAP::Data‚àí>type(base64 => $string)" either on client or on server
           side. If you want change behavior for specific instance of
           SOAP::Lite, you may subclass "SOAP::Serializer", override
           "as_string()" method that is responsible for string encoding (take
           a look into "as_base64()") and specify [1mnew [22mserializer class for
           your SOAP::Lite object with:

             my $soap = new SOAP::Lite
               serializer => My::Serializer‚Äê>new,
               ..... other parameters

           or on server side:

             my $server = new SOAP::Transport::HTTP::Daemon # or any other server
               serializer => My::Serializer‚Äê>new,
               ..... other parameters

           If you want to change this behavior for [1mall [22minstances of
           SOAP::Lite, just substitute "as_string()" method with "as_base64()"
           somewhere in your code [1mafter [22m"use SOAP::Lite" and [1mbefore [22mactual
           processing/sending:

             *SOAP::Serializer::as_string = \&SOAP::Serializer::as_base64;

           Be warned that last two methods will affect [1mall [22mstrings and convert
           them into base64 encoded. It doesn‚Äôt make any difference for
           SOAP::Lite, but it [1mmay [22mmake a difference for other toolkits.

       [1mWEBHOSTING INSTALLATION[0m

       As soon as you have telnet access to the box and XML::Parser is already
       installed there (or you have Perl 5.6 and can use XML::Parser::Lite)
       you may install your own copy of SOAP::Lite even if hosting provider
       doesn‚Äôt want to do it.

       Setup "PERL5LIB" environment variable. Depending on your shell it may
       look like:

         PERL5LIB=/you/home/directory/lib; export PERL5LIB

       "lib" here is the name of directory where all libraries will be
       installed under your home directory.

       Run CPAN module with

         perl ‚ÄêMCPAN ‚Äêe shell

       and run three commands from CPAN shell

         > o conf make_arg ‚ÄêI~/lib
         > o conf make_install_arg ‚ÄêI~/lib
         > o conf makepl_arg LIB=~/lib PREFIX=~ INSTALLMAN1DIR=~/man/man1 INSTALLMAN3DIR=~/man/man3

       "LIB" will specify directory where all libraries will reside.

       "PREFIX" will specify prefix for all directories (like [4mlib[24m, [4mbin[24m, [4mman[24m,
       though it doesn‚Äôt work in all cases for some reason).

       "INSTALLMAN1DIR" and "INSTALLMAN3DIR" specify directories for manuals
       (if you don‚Äôt specify them, install will fail because it‚Äôll try to
       setup it in default directory and you don‚Äôt have permissions for that).

       Then run:

         > install SOAP::Lite

       Now in your scripts you need to specify:

         use lib ‚Äô/your/home/directory/lib‚Äô;

       somewhere before ‚Äôuse SOAP::Lite;‚Äô

[1mBUGS AND LIMITATIONS[0m
       ¬∑   No support for multidimensional, partially transmitted and sparse
           arrays (however arrays of arrays are supported, as well as any
           other data structures, and you can add your own implementation with
           SOAP::Data).

       ¬∑   Limited support for WSDL schema.

       ¬∑   XML::Parser::Lite relies on Unicode support in Perl and doesn‚Äôt do
           entity decoding.

       ¬∑   Limited support for mustUnderstand and Actor attributes.

[1mPLATFORMS[0m
       MacOS
           Information about XML::Parser for MacPerl could be found here:
           http://bumppo.net/lists/macperl‚àímodules/1999/07/msg00047.html

           Compiled XML::Parser for MacOS could be found here:
           http://www.perl.com/CPAN‚àílocal/authors/id/A/AS/ASAND‚Äê
           STRM/XML‚àíParser‚àí2.27‚àíbin‚àí1‚àíMacOS.tgz

[1mAVAILABILITY[0m
       You can download the latest version SOAP::Lite for Unix or SOAP::Lite
       for Win32 from http://soaplite.com/ .  SOAP::Lite is available also
       from CPAN ( http://search.cpan.org/search?dist=SOAP‚àíLite ).  You are
       very welcome to write mail to the author (paulclinger@yahoo.com) with
       your comments, suggestions, bug reports and complaints.

[1mSEE ALSO[0m
       SOAP SOAP/Perl library from Keith Brown ( http://www.develop.com/soap/
       ) or ( http://search.cpan.org/search?dist=SOAP )

[1mACKNOWLEDGMENTS[0m
       A lot of thanks to
         Tony Hong <thong@xmethods.net>,
         Petr Janata <petr.janata@i.cz>,
         Murray Nesbitt <murray@ActiveState.com>,
         Robert Barta <rho@bigpond.net.au>,
         Gisle Aas <gisle@ActiveState.com>,
         Carl K. Cunningham <cc@roberts.de>,
         Graham Glass <graham‚àíglass@mindspring.com>,
         Chris Radcliff <chris@velocigen.com>,
         Arun Kumar <u_arunkumar@yahoo.com>,
         and many many others for provided help, feedback, support, patches
       and comments.

[1mCOPYRIGHT[0m
       Copyright (C) 2000‚àí2001 Paul Kulchenko. All rights reserved.

       This library is free software; you can redistribute it and/or modify it
       under the same terms as Perl itself.

[1mAUTHOR[0m
       Paul Kulchenko (paulclinger@yahoo.com)



perl v5.8.0                       2002‚Äê04‚Äê15                     SOAP::Lite(3)
