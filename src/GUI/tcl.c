/* Interface between prolog & Tcl/Tk */#define TCL_EXTENSIONS#include <tcl.h>#include <tk.h>#ifdef TCL_EXTENSIONS#include <tclExtend.h>#include <blt.h>extern int Blt_SafeInit _ANSI_ARGS_((Tcl_Interp *interp));#endif#include "prolog.h"static Tcl_Interp *interp = NULL;intTcl_AppInit(Tcl_Interp *interp){	if (Tcl_Init (interp) == TCL_ERROR)	{		warning("Tcl_Init failed.");		return TCL_ERROR;    	}	if (Tk_Init(interp) == TCL_ERROR)	{		warning("Tk_Init failed.");        	return TCL_ERROR;    	}    	Tcl_StaticPackage(interp, "Tk", Tk_Init, Tk_SafeInit);#ifdef TCL_EXTENSIONS	if (Tclx_Init(interp) == TCL_ERROR)	{		warning("Tclx_Init failed.");        	return TCL_ERROR;    	}    	Tcl_StaticPackage(interp, "Tclx", Tclx_Init, Tclx_SafeInit);    	if (Tkx_Init(interp) == TCL_ERROR)	{		warning("Tkx_Init failed.");        	return TCL_ERROR;    	}    	Tcl_StaticPackage(interp, "Tkx", Tkx_Init, (Tcl_PackageInitProc *) NULL);    	if (Blt_Init(interp) == TCL_ERROR)	{		warning("Blt_Init failed.");        	return TCL_ERROR;    	}	Tcl_StaticPackage(interp, "BLT", Blt_Init, Blt_SafeInit);	if (Tcl_Eval(interp, "namespace import blt::*") == TCL_ERROR)		fail(interp->result);	if (Tcl_Eval(interp, "namespace import -force blt::tile::*") == TCL_ERROR)		fail(interp->result);#endif	return TCL_OK;}static intp_tcl_create_interp(term goal, term *frame){	if (interp)		fail("A Tcl interpreter already exists");	interp = Tcl_CreateInterp();	if (Tcl_AppInit(interp) == TCL_ERROR)	{		Tcl_DeleteInterp(interp);		interp = NULL;		fail("Tcl interpreter initialisation failed");	}	return(TRUE);}static intp_tcl_delete_interp(term goal, term *frame){	if (! interp)		fail("There is no interpreter to destroy");		Tcl_DeleteInterp(interp);	interp = NULL;	return(TRUE);	}static intp_tcl_eval(term goal, term *frame){	term script = check_arg(1, goal, frame, ATOM, IN);	term result = check_arg(2, goal, frame, ATOM, OUT);	if (! interp)		fail("No Tcl interpreter");		if (Tcl_Eval(interp, NAME(script)) == TCL_ERROR)		fail(interp->result);	return(unify(result, frame, intern(interp->result), frame));}static intp_tcl_load_file(term goal, term	*frame){	term file = check_arg(1, goal, frame, ATOM, IN);	term result = check_arg(2, goal, frame, ATOM, OUT);	if (! interp)		fail("No Tcl interpreter");		if (Tcl_EvalFile(interp, NAME(file)) == TCL_ERROR)		fail(interp -> result);	return(unify(result, frame, intern(interp -> result), frame));}static intp_tcl_eval_file(term goal, term	*frame){	term file = check_arg(1, goal, frame, ATOM, IN);	term result = check_arg(2, goal, frame, ATOM, OUT);	if (! interp)		fail("No Tcl interpreter");		if (Tcl_EvalFile(interp, NAME(file)) == TCL_ERROR)		fail(interp->result);	Tk_MainLoop();	return(unify(result, frame, intern(interp->result), frame));}static intp_tcl_global_eval(term goal, term *frame){	term script = check_arg(1, goal, frame, ATOM, IN);	term result = check_arg(2, goal, frame, ATOM, OUT);	if (! interp)		fail("No Tcl interpreter");		if (Tcl_GlobalEval(interp, NAME(script)) == TCL_ERROR)		fail(interp->result);	return(unify(result, frame, intern(interp->result), frame));}static intp_tcl_convert_list(term goal, term *frame){	int	sItemCount, sItem;	char	**pItems;	term	list = _nil;	term tcllist = check_arg(1, goal, frame, ATOM, IN);	term plglist = check_arg(2, goal, frame, LIST, OUT);	if (! interp)		fail("No Tcl interpreter");		if (Tcl_SplitList(interp, NAME(tcllist), &sItemCount, &pItems) == TCL_ERROR)		fail(interp->result);	for (sItem = sItemCount - 1; sItem >= 0; sItem--)		list = gcons(intern(pItems[sItem]), list);	Tcl_Free((char *) pItems);	return(unify(plglist, frame, list, frame));}/************************************************************************//*		Finalise all modules. Called on exit			*//************************************************************************/static voidfinalise(void){	tcl_done();}/************************************************************************//*			   TCL Intialisation                       	*//************************************************************************/voidtcl_init(void){	/* register finalise to be called on exit */	atexit(finalise);     	new_pred(p_tcl_create_interp, "tcl_create_interp");	new_pred(p_tcl_delete_interp, "tcl_delete_interp");	new_pred(p_tcl_eval, "tcl_eval");	new_pred(p_tcl_eval_file, "tcl_load_file");	new_pred(p_tcl_eval_file, "tcl_eval_file");	new_pred(p_tcl_global_eval, "tcl_global_eval");	new_pred(p_tcl_convert_list, "tcl_convert_list");}