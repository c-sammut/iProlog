/************************************************************************//*    Naive implementation of Plotkin's Least General Generalisation	*//************************************************************************/#include "prolog.h"extern term *local, *global, trail;extern term varlist, new_clause();static term substitution, _tag, _const;static int nvars;#define SUB_FLAG	128#define SET_SUB(x)	FLAGS(x) |= SUB_FLAG#define UNSET_SUB(x)	FLAGS(x) &= ~SUB_FLAG#define SUBSUMED(x)	(FLAGS(x) & SUB_FLAG)/************************************************************************//*	lookup inverse substitution					*//*	Inverse substitution is stored in a list as [V/(T1, T2)]	*//************************************************************************/static termlookup(term t1, term t2){	term rval, *p;	for (p = &substitution; *p != _nil; p = &CDR(*p))	{		term antisub = CAR(*p);		term pair = ARG(2, antisub);		if (term_compare(t1, NULL, ARG(1, pair), NULL) == 0 &&		    term_compare(t2, NULL, ARG(2, pair), NULL) == 0)			return(ARG(1, antisub));	}	*p = gcons(g_fn2(intern("/"), rval = new_ref(), g_fn2(_comma, t1, t2)), _nil);	nvars++;	return(rval);}/************************************************************************//*		     lgg_term - find the lgg of two terms		*//************************************************************************/static termlgg_term(term t1, term *f1, term t2, term *f2){L2:	if (t1 == t2) return(t1);	switch (TYPE(t2))	{	   case ANON:			fail("Can't find lgg of anonymous variable");	   case FREE:			f2[OFFSET(t2)] = new_ref();	   case BOUND:			t2 = f2[OFFSET(t2)];			goto L2;	   case REF:			if (POINTER(t2) == NULL)				break;			t2 = POINTER(t2);			goto L2;	}L1:	if (t1 == t2) return(t1);	switch (TYPE(t1))	{	   case ATOM:	 		break;	   case ANON:			fail("Can't find lgg of anonymous variable");	   case FREE:			f1[OFFSET(t1)] = new_ref();	   case BOUND:			t1 = f1[OFFSET(t1)];			goto L1;	   case REF:			if (POINTER(t1) == NULL)				break;			t1 = POINTER(t1);			goto L1;	   case INT:			if (TYPE(t2) == INT)				if (IVAL(t1) == IVAL(t2))					return(copy(t1, f1));			if (TYPE(t2) == REAL)				if ((double) IVAL(t1) == RVAL(t2))					return(copy(t1, f1));			break;	   case REAL:			if (TYPE(t2) == REAL)				if (RVAL(t1) == RVAL(t2))					return(copy(t1, f1));			if (TYPE(t2) == INT)				if (RVAL(t1) == (double) IVAL(t2))					return(copy(t1, f1));			break;	   case FN:	   		if (ARG(0, t1) == _const && ARG(0, t2) == _const)				if (term_compare(t1, f1, t2, f2) == 0)					return(copy(t1, f1));			if (TYPE(t2) == FN && ARITY(t1) == ARITY(t2) && ARG(0, t1) == ARG(0, t2))			{				int i, a = ARITY(t1);		   		term rval = galloc(sizeof(compterm) + a * WORD_LENGTH);				TYPE(rval) = TYPE(t1);				FLAGS(rval) = COPY;				ARITY(rval) = a;				ARG(0, rval) = ARG(0, t1);				for (i = 1; i <= a; i++)					ARG(i, rval) = lgg_term(ARG(i, t1), f1, ARG(i, t2), f2);				return(rval);			}			break;	   case LIST:			if (TYPE(t2) == LIST)				return gcons(lgg_term(CAR(t1), f1, CAR(t2), f2),					     lgg_term(CDR(t1), f1, CDR(t2), f2));			break;	   default:			fail("Can't find lgg of that term");	}	return(lookup(t1, t2));}/************************************************************************//*	Call lgg_lit to find lgg of two literals in a clause		*//************************************************************************/static termlgg_lit(term t1, term *f1, term t2, term *f2){	term tag1 = NULL, tag2 = NULL, rval;	t1 = unbind(t1, f1);	t2 = unbind(t2, f2);	if (TYPE(t1) == FN && ARG(0, t1) == _tag)		if (TYPE(t2) == FN && ARG(0, t2) == _tag)		{			tag1 = ARG(1, t1);			t1 = ARG(2, t1);			tag2 = ARG(1, t2);			t2 = ARG(2, t2);			if (term_compare(tag1, f1, tag2, f2) != 0)				return(NULL);		}	if (t1 == t2) return(t1);	if (TYPE(t1) != FN) return(NULL);	if (TYPE(t2) != FN) return(NULL);	if (ARG(0, t1) != ARG(0, t2)) return(NULL);	rval = lgg_term(t1, f1, t2, f2);	if (tag1 == NULL || tag2 == NULL)		return(rval);	return(g_fn2(_tag, tag1, rval));}/************************************************************************//*	Find the LGG of two clauses as stored in Prolog's data base	*//************************************************************************/static termlgg_db(term c1, term c2){	term *f1 = new_local_frame(NVARS(c1));	term *f2 = new_local_frame(NVARS(c2));	term *p, *q, rval, lit_list, *last;	term old_varlist = varlist;	term *old_global = global;	term old_trail = trail;	int i, ngoals = 0;	substitution = _nil;	varlist = _nil;	nvars = 0;	if (HEAD(c1) == HEAD(c2))		lit_list = gcons(HEAD(c1), _nil);	else if (TYPE(HEAD(c1)) == FN && TYPE(HEAD(c2)) == FN && ARG(0, HEAD(c1)) == ARG(0, HEAD(c2)))		lit_list = gcons(lgg_lit(HEAD(c1), f1, HEAD(c2), f2), _nil);	else		return(NULL);	last = &CDR(lit_list);	for (p = BODY(c1); *p != NULL; p++)		for(q = BODY(c2); *q != NULL; q++)		{			term lit = lgg_lit(*p, f1, *q, f2);				if (lit != NULL)			{				*last = gcons(lit, _nil);				last = &CDR(*last);				ngoals++;			}		}	rval = new_clause(ngoals);	NVARS(rval) = nvars;	for (i = 0; i <= ngoals; i++, lit_list = CDR(lit_list))		GOAL(i, rval) = make(CAR(lit_list), NULL);	untrail(old_trail);	varlist = old_varlist;	global = old_global;	local = f1;/* 	fputc('\n', output);	print(c1);	print(c2);	fprintf(output, "======================\n");	print(rval); */	return(rval);}/************************************************************************//*	This is the hook to call the lgg procedure from Prolog		*//************************************************************************/static intp_lgg_db(term goal, term *frame){	term c1 = check_arg(1, goal, frame, CLAUSE, IN);	term c2 = check_arg(2, goal, frame, CLAUSE, IN);	term c3 = check_arg(3, goal, frame, CLAUSE, OUT);	term rval = NULL;	if ((rval = lgg_db(c1, c2)) == NULL)		return(FALSE);	return(unify(c3, frame, rval, frame));}/************************************************************************//*		Test if one clause subsumes another			*//************************************************************************/static intsubsumes_body(term *b1, term *f1, term *b2, term *f2){	term *old_global = global;	term old_trail = trail;	term *p, *q;	if (*b1 == NULL)		return(TRUE);	for (q = b2; *q != NULL; q++)	{		if (unify(*b1, f1, *q, f2))			if (subsumes_body(b1+1, f1, b2, f2))				rest_of_clause();		untrail(old_trail);		global = old_global;	}	return(FALSE);}static intsubsumes_clause(term goal, term *frame){	term c1 = check_arg(1, goal, frame, CLAUSE, IN);	term c2 = check_arg(2, goal, frame, CLAUSE, IN);	term *f1 = new_local_frame(NVARS(c1));	term *f2 = new_local_frame(NVARS(c2));	int rval = FALSE;	if (unify(HEAD(c1), f1, HEAD(c2), f2))		rval = subsumes_body(BODY(c1), f1, BODY(c2), f2);	return(rval);}/************************************************************************//* A call to numbervars is needed to prevent unwatned variable matches	*//************************************************************************/static voidnumvars(term t, term *f){	static int count = 0;	numbervars(t, f, &count);}/************************************************************************//* Called from "subset"							*//* tests if body of first clause is contained in second			*//************************************************************************/static intsubset_test(term *b1, term *f1, term *b2, term *f2){	term *old_global = global;	term old_trail = trail;	term *p, *q;	if (*b1 == NULL)		return(TRUE);	for (q = b2; *q != NULL; q++)	{		make_ref(*q, f2);		numvars(*q, f2);		if (unify(*b1, f1, *q, f2))		{/* 			fprintf(output, "==================\n");			prin(*b1); fputc('\t', output); rprint(*b1, f1); fflush(output);			prin(*q); fputc('\t', output); rprint(*q, f2); fflush(output); */			if (subset_test(b1+1, f1, b2, f2))			{				untrail(old_trail);				global = old_global;				return(TRUE);			}		}		untrail(old_trail);		global = old_global;	}	return(FALSE);}/************************************************************************//*	Unify heads of two clauses so that I/O variables match		*//************************************************************************/static intmatch_head(term h1, term *f1, term h2, term *f2){	int i;	if (ARITY(h1) != ARITY(h2))		fail("positive and negative examples differ in the number of arguments");;	for (i = 1; i <= ARITY(h1); i++)		if (! unify(ARG(i, h1), f1, ARG(i, h2), f2))			return(FALSE);	return(TRUE);}/************************************************************************//* Test if one clause subsumes another					*//* First match heads of clause and then check if bodu of first clause	*//* is a subset of body of second clause					*//************************************************************************/static intsubset(term c1, term c2){	term *f1 = new_local_frame(NVARS(c1));	term *f2 = new_local_frame(NVARS(c2));	term *old_global = global;	term old_trail = trail;		int rval = FALSE;	if (match_head(HEAD(c1), f1, HEAD(c2), f2))	{		numvars(HEAD(c2), f2);		rval = subset_test(BODY(c1), f1, BODY(c2), f2);	}/* 	fprintf(output, "*** %s SUBSET ***\n", rval ? "IS " : "NOT");	print(c1);	print(c2);	fprintf(output, "***\n"); */	untrail(old_trail);	global = old_global;	local = f1;	return(rval);}/************************************************************************//* Loop through list of negative examples to check if clause covers one	*//************************************************************************/static intcovers_neg(term c, term neglist){	term p = neglist;	while (p != _nil)	{		term q = CAR(p);		if (TYPE(q) != ATOM)			fail("List of negative predicates must only contain atoms");		if ((q = PROC(q)) == NULL)			fail("Undefined neative relation");		while (q != NULL)		{			if (subset(c, q))				return(TRUE);			q = NEXT(q);		}		p = CDR(p);		DEREF(p);	}	return(FALSE);}/************************************************************************//* Insert a new LGG into clause list.					*//* If a clause already subsumes new one, forget it			*//* Remove from list any clauses subsumsed by new one			*//************************************************************************/static voidinsert(term new_clause, term *clause_list){	term *last = clause_list;	while (*last != NULL)		if (subset(*last, new_clause))			return;		else if (subset(new_clause, *last))			*last = NEXT(*last);		else			last = &NEXT(*last);	*last = new_clause;}/************************************************************************//*			Finds the LGG of a relation			*//************************************************************************/static termlgg_reln(term clause_list, term neglist){	term p, q, lgg;	term rval = NULL;	int changed = FALSE;	for (p = clause_list; p != NULL; p = NEXT(p))		UNSET_SUB(p);	for (p = clause_list; p != NULL; p = NEXT(p))		for (q = NEXT(p); q != NULL; q = NEXT(q))			if ((lgg = lgg_db(p, q)) != NULL && ! covers_neg(lgg, neglist))			{ 				if (subset(p, lgg) || subset(q, lgg))				{					fprintf(output, "SKIP\n");					continue;				} 				changed = TRUE;/* 				fprintf(output, "INSERT: "); print(lgg); */				SET_SUB(p);				SET_SUB(q);				UNSET_SUB(lgg);				insert(lgg, &rval);			}	if (! changed)		return(NULL);/* 	fprintf(output, "************\n"); */	p = clause_list;	while (p != NULL)	{		q = NEXT(p);/* 		print(p); */		if (! SUBSUMED(p))		{			NEXT(p) = NULL;			insert(p, &rval);/* 			fprintf(output, "INSERTed\n"); */		}/* 		else			fprintf(output, "NOT INSERTED\n"); */		p = q;	}	return(rval);}/************************************************************************//*		Prolog hook for call to lgg of a relation		*//************************************************************************/static intp_lgg_reln(term goal, term *frame){	term pos = check_arg(1, goal, frame, ATOM, IN);	term neglist = check_arg(2, goal, frame, LIST, IN);	term rval, x;	if (PROC(pos) == NULL)		fail("Undefined relation");	rval = lgg_reln(PROC(pos), neglist);/* 	list_proc(rval); */	while (x  = lgg_reln(rval, neglist))	{		rval = x;/* 		fprintf(output, "______________________\n");		list_proc(rval); */	}	list_proc(rval);	return(TRUE);}/************************************************************************//* These procedures are for clauses represented as comma-separated	*//* compound terms.							*//************************************************************************/static term *append(term *conjunction, term lgg){	if (lgg != NULL)		if (*conjunction == NULL)			*conjunction = lgg;		else		{			*conjunction = g_fn2(_comma, *conjunction, lgg);			conjunction = &ARG(2, *conjunction);		}	return(conjunction);}static term *lgg_body_lit(term lit, term *lit_frame, term body, term *body_frame, term *rval){	term x;	for (x = unbind(body, body_frame); ARG(0, x) == _comma; x = unbind(ARG(2, x), body_frame))		rval = append(rval, lgg_lit(lit, lit_frame, ARG(1, x), body_frame));	rval = append(rval, lgg_lit(lit, lit_frame,  x, body_frame));	return(rval);}static termlgg_body(term t1, term *f1, term t2, term *f2){	term x, rval = NULL, *p = &rval;	t1 = unbind(t1, f1);	t2 = unbind(t2, f2);	for (x = t1; ARG(0, x) == _comma; x = unbind(ARG(2, x), f1))		p = lgg_body_lit(ARG(1, x), f1, t2, f2, p);	lgg_body_lit(x, f1, t2, f2, p);	return(rval);}static termlgg_clause(term t1, term *f1, term t2, term *f2){	if (ARG(0, t1) == _neck && ARG(0, t2))	{		term lgg_h, lgg_b;		if ((lgg_h = lgg_lit(ARG(1, t1), f1, ARG(1, t2), f2)) == NULL)			return(NULL);		if ((lgg_b = lgg_body(ARG(2, t1), f1, ARG(2, t2), f2)) == NULL)			return(lgg_h);		return(g_fn2(_neck, lgg_h, lgg_b));	}	return(lgg_lit(t1, f1, t2, f2));}static intlgg(term goal, term *frame){	term x = check_arg(1, goal, frame, FN, IN);	term y = check_arg(2, goal, frame, FN, IN);	term l = check_arg(3, goal, frame, FN, OUT);	term s = check_arg(4, goal, frame, LIST, OUT);	term rval;	substitution = _nil;	nvars = 0;	if ((rval = lgg_clause(x, frame, y, frame)) == NULL)		return(FALSE);	unify(l, frame, rval, frame);	unify(s, frame, substitution, frame);	return(TRUE);}/************************************************************************//*			   Initialise Module				*//************************************************************************/voidlgg_init(void){	_tag = intern("@");	_const = intern("#");	new_pred(subsumes_clause,	"subsumes");	new_pred(lgg,			"lgg");	new_pred(p_lgg_db,		"lgg_clause");	new_pred(p_lgg_reln,		"lgg_reln");}